\documentclass[a4paper,11pt]{article}
\parskip 3pt

%% %%%%%%%%%%%%%%%%%%%% BEGIN PACKAGES %%%%%%%%%%%%%%%%%%%%

%%\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\usepackage{fullpage}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\hypersetup{pdfborder=0 0 0}

%% Images
\usepackage{graphicx}

%% Side-by-side images
\usepackage{subfig}

%% Wrapped figures
\usepackage{wrapfig}

%% Drawing trees and other stuff
\usepackage{tikz}
\usetikzlibrary{trees,arrows}
\usepackage{amssymb}

%% Pseudocode
\usepackage[noend]{algorithmic}
\algsetup{indent=1.5em}

%% Linux Libertine
\usepackage[T1]{fontenc}
\usepackage{libertine}
\renewcommand*\oldstylenums[1]{{\fontfamily{fxlj}\selectfont #1}}

\let\stdhref\href
\renewcommand{\href}[2]{\stdhref{#1}{\texttt{#2}}}

\newcommand{\mailto}[1]{\href{mailto:#1}{#1}}

\let\stdsection\section         % because LaTeX cannot handle
                                % recursive commands
\renewcommand{\section}{\newpage\stdsection}

\let\tikzsquare\square
\renewcommand{\square}{\ensuremath\tikzsquare}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\buzz}[1]{\emph{#1}}
\newcommand{\magic}[1]{\buzz{#1}}

\newcommand{\myhref}[1]{\href{http://#1}{#1}}

%% Clubs and widows. Avoid them like the plague.
\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

%% %%%%%%%%%%%%%%%%%%%% END COMMANDS %%%%%%%%%%%%%%%%%%%%

%Visigoth is a tool to generate, analyse and visualise Small World
%Networks. These are particular kinds of graphs which \emph{look} like naturally
%grown networks and share many mathematical properties with them.  For instance,
%friendship graphs and graphs of followers in modern web-based ``social
%networks'' are Small World Networks.

%As an educational tool Visigoth allows users to explore Small World Networks and
%hence can be used as an introduction to them. By exploring these networks users
%will have a firmer, more intuitive grasp of the mathematical properties they
%exhibit.

%The networks may be generated using several algorithms, allowing users to
%compare their output and its adherence to the properties of Small World
%Networks. The network generation algorithms in Visigoth form a smooth
%progression in the number of exhibited desired properties from completely random
%graphs, generated by the Erd\H{o}s-R\'{e}nyi algorithm, to fully compliant Small
%World Networks, generated by the Preferential Attachment
%algorithm. Additionally, Visigoth can connect to social networking platforms
%such as \Twitter to fetch and display real-world networks.

%We should keep it 2 pages long at most and should have the same structure as
%the Report

\begin{document}
\title{Visigoth --- Graph Visualisations}
\author{
  Andreea-Ingrid Funie\\\mailto{aif109@doc.ic.ac.uk}\and
  Alexandru Scvor\c tov\\\mailto{as10109@doc.ic.ac.uk}\and
  Francesco Mazzoli\\\mailto{fm2209@doc.ic.ac.uk}\and
  Marc-David Haubenstock\\\mailto{mh808@doc.ic.ac.uk}\and
  Maximilian Staudt\\\mailto{ms9109@doc.ic.ac.uk}
}
\date{}
\maketitle

\begin{description}
\item[Introduction]
  % High Level, Nontechnical Description Why you should buy this
  % product/listen to this presentation? What is the
  % functionality of the product?

  Visigoth is a tool to generate, analyse and visualise Small World
  Networks. These are particular kinds of graphs which \emph{look}
  like naturally grown networks and share many mathematical properties
  with them.  For instance, graphs of followers in social networks,
  graphs of links between websites and graphs of academic citations
  are Small World Networks.

  \item[Functionality]
  % Should we add here what is able to do?

  Visigoth is an educational tool that introduces these graphs by
  example.  Exploring these in 2D/3D, users gain a firm and intuitive
  grasp of the mathematical properties they exhibit.

  Mathematically, Small World Networks are graphs that exhibit three
  properties: low average path length, high clustering, and scale-free
  degree distribution.

  Visigoth generates networks with several algorithms, which present a
  smooth progression in the number of desired properties their output
  exhibits. The algorithms are: Erd\H{o}s-R\'{e}nyi, Watts-Strogatz,
  Barabasi-Albert, Bipartite, and Preferential attachment with
  clustering. Additionally, Visigoth can connect to social networking
  platforms such as Twitter to fetch and display real-world networks.

  Users can regenerate graphs, add nodes, tweak node layouts, move
  nodes, reshuffle nodes, highlight nodes and cliques. They can also
  zoom in/out, pan, rotate graphs. In 3D mode, they can ``fly''
  through the graph.

  Users may also customize the appearance of the generated graph by
  changing the colour of edges and nodes, choosing a different
  background. Finally, Visigoth supports taking snapshots of graphs
  and exporting them to PNG or JPEG files.

\item[Technical Description]
  % B. Short Technical Description; Short introduction into
  % technologies used Design of your software, possibly including a
  % diagram of the major components of the project; Main achievements

  While building Visigoth, we employed a variety of tools and techniques to make
  the best of our machines:

  \begin{description}
    \item[Qt] To model the UI, we use Nokia's brilliant framework. Qt ships with
      a permissive license, has excellent cross-platform supports, and comes
      with a comprehensive library along with a meta-object system on top of C++
      objects. These features considerably ease the pain of C++ development, and
      development time would have definitely been longer without Qt.

    \item[Force-directed algorithm] To draw our graphs, we use an optimised,
      state of the art force-directed algorithm. This class of algorithms works
      by treating each nodes as a charged particle and each edge as a rubber
      band. In this way, nodes tend to repel each other while edges keep
      clusters together. Our implementation worked great but was too slow for
      large graph. For this reason, we sped it up implementing a 3D version of
      the FADE algorithm, which works by approximation by subdividing the space
      and then treat in sub-spaces as nodes, instead of analysing each node.

    \item[C++] C++, while being a very complex and fairly low level language,
      has served us well. This is mainly due to the excellent availability of
      tools, the fine-grained control resulting in better performance, and the
      its abstraction capabilities. However, we often fought against its
      complexity and unmanaged nature.

    \item[OpenGL] Finally, our graph rendered is implemented in straight OpenGL,
      for performance reason. After trying other backends (Cairo, Qt), and
      realising that we would not be able to render more than a few nodes with
      them, we went the hardware accelerated way with OpenGL. This way, we are
      able of drawing 10s of thousands of nodes while being able to pan, zoom,
      and select our graph both in 3D and 2D.
  \end{description}

\item[Software Engineering Issues]
  % C. Software Engineering Issues: What technology was used and why;
  % what other technology was considered but not used and why; Any
  % technical challenges encountered and how addressed; Any risks
  % anticipated, and how mitigated? Any collaboration/coordination
  % difficulties encountered and how addressed; Development and
  % testing methods and/or tools used; comparison of plans with actual
  % achievements; Estimates of length of code in each of the
  % components, or any other comparable measure of the effort
  % required; Summary of each team member's contributions

  We encountered a number of difficulties whilst building Visigoth,
  which we over- came by dividing the application into
  mostly-independent components.  The following sections provide
  overviews and short descriptions for each component.

  \begin{description}
  \item[Tests] The test system is heavily oriented towards
    functionality testing, checking that user actions cause the
    expected behaviour.

  \item[GUI] The GUI is the only user-visible component. It was relies
    heavily on Qt's widget library and OpenGL.

  \item[GraphScene] We took an Model-View-Controller approach in
    Visigoth's design. Whist the GUI system is the view, the
    GraphScene is the model and encap- sulates the controller.

  \item[Algorithms] The last component of Visigoth are the
    algorithms. All the individual algorithms implement the Algorithm
    interface, which allows them to be easily plugged into the
    GraphScene.
  \end{description}

  Work was divided between team members such that each would focus on
  developing a particular component and reviewing another. We chose an
  iterative development model, where each iteration consisted of
  adding a small number of features to the existing product.

  We have had to ensure that no bugs crept into the master
  branch. Towards this goal, no changes are merged into master until
  at least another member of the team reviews them. Through this
  practice of peer review the whole team has stayed informed on the
  current state of the project in addition to exposing and fixing bugs
  missed by the original code author.

  To further promote group awareness of the complete state of the
  project we held frequent short meetings true to the idea of
  \emph{scrum}. These were whole-group meetings held every few days,
  in which team members shared comments on what features they were
  working on at the time and the future outlook of the project.

  While our development methodology was not test-driven or focused on
  usability, we continuously tested the software on volunteers and
  towards the end of each iteration, we held meetings with our
  client. These tests and meetings uncovered a few problems, which
  eventually lead to small redesigns.

\item[Validation]
  % D. Validation and Conclusions How did you validate your product?

  During our product validation we distinguished between \emph{the
    client} (i.e.  the person ``paying'' for the development of
  Visigoth) and \emph{the users} (i.e. the people who would end up
  using Visigoth).

  We held meetings with \emph{the client} near the end of each
  iteration in order to report on our progress and to get feedback on
  new developments. These meetings would consist of a short demo of
  newly added features, a short ``impromptu'' usability test and a
  discussion on what new features should be the focus of the following
  iteration.

  The feedback we received at the end of each iteration was
  consistently positive. The Visigoth interface always met our
  client's demands and only minor changes have been made from
  iteration to iteration

  Furthermore, we asked classmates and friends to try out
  accomplishing certain tasks in Visigoth while we watched. At the
  end, we would ask what felt awkward or wrong.

  The lasting impression was that they were happy with the software,
  but watching them struggle with certain aspects led to improvements
  in usability.

\item[Conclusions]
  % Was the project successful? What did you learn? What might you
  % have done differently?

  Our team has thoroughly enjoyed the process that led to the creation
  of Visigoth. As of today, we are very proud of the result and we plan to
  release it to the wider public in the near future.

  While we could have improved in some areas, the development of
  Visigoth has been very successful in what matters more: constantly
  delivering, on time, the features requested by the client while
  maintaining a clean and maintainable code base.
  For this reason we are satisfied not only with the end
  result, but also with how smooth the development process was, and we
  think our client is satisfied as well.

\end{description}

\end{document}
