\documentclass[a4paper,11pt]{article}
\parskip 3pt

%% %%%%%%%%%%%%%%%%%%%% BEGIN PACKAGES %%%%%%%%%%%%%%%%%%%%

%%\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\usepackage{fullpage}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\hypersetup{pdfborder=0 0 0}

%% Images
\usepackage{graphicx}

%% Side-by-side images
\usepackage{subfig}

%% Wrapped figures
\usepackage{wrapfig}

%% Drawing trees and other stuff
\usepackage{tikz}
\usetikzlibrary{trees,arrows}
\usepackage{amssymb}

%% Pseudocode
\usepackage[noend]{algorithmic}
\algsetup{indent=1.5em}

%% Linux Libertine
\usepackage[T1]{fontenc}
\usepackage{libertine}
\renewcommand*\oldstylenums[1]{{\fontfamily{fxlj}\selectfont #1}}

\let\stdhref\href
\renewcommand{\href}[2]{\stdhref{#1}{\texttt{#2}}}

\newcommand{\mailto}[1]{\href{mailto:#1}{#1}}

\let\stdsection\section         % because LaTeX cannot handle
                                % recursive commands
\renewcommand{\section}{\newpage\stdsection}

\let\tikzsquare\square
\renewcommand{\square}{\ensuremath\tikzsquare}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\buzz}[1]{\emph{#1}}
\newcommand{\magic}[1]{\buzz{#1}}

\newcommand{\myhref}[1]{\href{http://#1}{#1}}

\newcommand{\Qt}{\buzz{Qt} }
\newcommand{\Cpp}{\buzz{C++} }
\newcommand{\OpenGL}{\buzz{OpenGL} }
\newcommand{\FADE}{\buzz{FADE} }

%% Clubs and widows. Avoid them like the plague.
\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

%% %%%%%%%%%%%%%%%%%%%% END COMMANDS %%%%%%%%%%%%%%%%%%%%

%Visigoth is a tool to generate, analyse and visualise Small World
%Networks. These are particular kinds of graphs which \emph{look} like naturally
%grown networks and share many mathematical properties with them.  For instance,
%friendship graphs and graphs of followers in modern web-based ``social
%networks'' are Small World Networks.

%As an educational tool Visigoth allows users to explore Small World Networks and
%hence can be used as an introduction to them. By exploring these networks users
%will have a firmer, more intuitive grasp of the mathematical properties they
%exhibit.

%The networks may be generated using several algorithms, allowing users to
%compare their output and its adherence to the properties of Small World
%Networks. The network generation algorithms in Visigoth form a smooth
%progression in the number of exhibited desired properties from completely random
%graphs, generated by the Erd\H{o}s-R\'{e}nyi algorithm, to fully compliant Small
%World Networks, generated by the Preferential Attachment
%algorithm. Additionally, Visigoth can connect to social networking platforms
%such as \Twitter to fetch and display real-world networks.

%We should keep it 2 pages long at most and should have the same structure as
%the Report

\begin{document}
\title{Visigoth --- Graph Visualisations}
\author{
  Andreea-Ingrid Funie\\\mailto{aif109@doc.ic.ac.uk}\and
  Alexandru Scvor\c tov\\\mailto{as10109@doc.ic.ac.uk}\and
  Francesco Mazzoli\\\mailto{fm2209@doc.ic.ac.uk}\and
  Marc-David Haubenstock\\\mailto{mh808@doc.ic.ac.uk}\and
  Maximilian Staudt\\\mailto{ms9109@doc.ic.ac.uk}
}
\date{}
\maketitle

\begin{description}
\item[Introduction]
  % High Level, Nontechnical Description Why you should buy this
  % product/listen to this presentation? What is the
  % functionality of the product?

  Visigoth is a tool to generate, analyse and visualise Small World
  Networks. These are particular kinds of graphs which \emph{look}
  like naturally grown networks and share many mathematical properties
  with them.  For instance, graphs of followers in social networks,
  graphs of links between websites and graphs of academic citations
  are Small World Networks.

  \item[Functionality]
  % Should we add here what is able to do?

  Visigoth is an educational tool that introduces these graphs by
  example.  Exploring these in 2D/3D, users gain a firm and intuitive
  grasp of the mathematical properties they exhibit.

  Mathematically, Small World Networks are graphs that exhibit three
  properties: low average path length, high clustering, and scale-free
  degree distribution.

  Visigoth generates networks with several algorithms which present a
  smooth progression in the number of desired properties their output
  exhibits. The algorithms are: Erd\H{o}s-R\'{e}nyi, Watts-Strogatz,
  Barabasi-Albert, Bipartite, and Preferential attachment with
  clustering. Additionally, Visigoth can connect to social networking
  platforms such as Twitter to fetch and display real-world networks.

  Users can regenerate graphs, add nodes, tweak node layouts, move
  nodes and reshuffle nodes as well as highlight nodes and their
  edges. They can also zoom in/out and pan graphs, and in 3D mode
  they can ``fly'' through the graph and rotate it.

  Users may also customize the appearance of the generated graph by
  changing the colour of the edges, the nodes and the background.
  Finally, Visigoth supports taking snapshots of graphs and exporting
  them to PNG or JPEG files.

\item[Technical Description]
  % B. Short Technical Description; Short introduction into
  % technologies used Design of your software, possibly including a
  % diagram of the major components of the project; Main achievements

  While building Visigoth, we employed a variety of tools and techniques to make
  the best of our machines:

  \begin{description}
    \item[\Qt] To model the UI, we use Nokia's brilliant framework. \Qt
      ships with a permissive license, has excellent cross-platform supports,
      and comes with a comprehensive library along with a meta-object system on
      top of \Cpp objects. These features considerably ease the pain of \Cpp
      development, and development time would have definitely been longer
      without \Qt.

    \item[Force-directed algorithm] To draw our graphs, we use an optimised,
      state of the art force-directed algorithm. This class of algorithms works
      by treating each nodes as a charged particle and each edge as a rubber
      band. In this way, nodes tend to repel each other while edges keep
      clusters together. Our implementation worked great but was too slow for
      large graph. For this reason, we sped it up implementing a 3D version of
      the \FADE algorithm, which works by approximation by subdividing the space
      and then sometimes treating in sub-spaces as nodes, instead of always
      analysing each node.

    \item[\Cpp] \Cpp, while being a very complex and fairly low level language,
      has served us well. This is mainly due to the excellent availability of
      tools, the fine-grained control resulting in better performance, and the
      its abstraction capabilities. However, we often fought against its
      complexity and unmanaged nature.

    \item[\OpenGL] Finally, our graph rendered is implemented in straight
      \OpenGL, for performance reasons. After trying other backends
      (\buzz{Cairo}, \Qt), and realising that we would not be able to render
      more than a few hundreds nodes with them, we went the hardware accelerated
      way with \OpenGL. This way, we are able of drawing 10s of thousands of
      nodes while being able to pan, zoom, and select our graph both in 3D and
      2D.
  \end{description}

\item[Software Engineering Issues]
  % C. Software Engineering Issues: What technology was used and why;
  % what other technology was considered but not used and why; Any
  % technical challenges encountered and how addressed; Any risks
  % anticipated, and how mitigated? Any collaboration/coordination
  % difficulties encountered and how addressed; Development and
  % testing methods and/or tools used; comparison of plans with actual
  % achievements; Estimates of length of code in each of the
  % components, or any other comparable measure of the effort
  % required; Summary of each team member's contributions

  We encountered a number of difficulties while building Visigoth
  which we overcame by dividing the application into mostly
  independent components. The following sections provide overviews
  and short descriptions for each component.

  \begin{description}
  \item[Tests] The test system is heavily oriented towards
    functionality testing, checking that user actions cause the
    expected behaviour.

  \item[GUI] The GUI is the only user-visible component. It was relies
    heavily on \Qt's widget library and \OpenGL.

  \item[GraphScene] We took a Model-View-Controller approach in
    Visigoth's design. While the GUI system is the view the
    GraphScene is the model and encapsulates the controller.

  \item[Algorithms] The last component of Visigoth are the graph
    generation algorithms. All algorithms implement the
    \code{Algorithm} interface which allows them to be plugged into
    the GraphScene with ease.
  \end{description}

  Work was divided within the team such that each member would focus
  on developing a particular component and reviewing another. We chose
  an iterative development model where each iteration consisted of
  adding a small number of features to the existing product.

  We had to ensure that no bugs crept into the master branch. In order
  to achieve this goal, no changes were allowed to be merged into
  master until at least one other member of the team reviewed them.
  By means of our consistent practice of peer review the whole team
  stayed informed about the current state of the project in addition
  to exposing and fixing bugs missed by the original code author.

  To further promote group awareness of the complete state of the
  project we held frequent short meetings true to the idea of
  \emph{scrum}. These were whole-group meetings held once every few
  days in which team members shared comments on the features they
  were working on at the time and the future outlook of the project.

  While our development methodology was not test-driven or focused on
  usability, we continuously tested the software on volunteers and
  towards the end of each iteration we held meetings with our client.
  These tests and meetings uncovered a few problems which eventually
  led to small redesigns.

\item[Validation]
  % D. Validation and Conclusions How did you validate your product?

  We held meetings with \emph{the client}\footnote{We distinguished
    between \emph{the client} (i.e.  the person ``paying'' for the
    development of Visigoth) and \emph{the users} (i.e. the people who
    would end up using Visigoth).} near the end of each iteration in
  order to report on our progress and to get feedback on new
  developments. These meetings would consist of a short demo of newly
  added features, a short ``impromptu'' usability test and a
  discussion on what new features should be the focus of the following
  iteration.

  The feedback received at the end of each iteration was consistently
  positive. As the interface always met our client's demands, only
  small changes were necessary from iteration to iteration.

  Furthermore, we asked friends (``users'') to try accomplishing
  certain tasks in Visigoth while we watched. At the end, we would ask
  what felt awkward or wrong. The lasting impression was that they
  were happy with the software, but watching them struggle with
  certain aspects led to improvements in usability.

\item[Conclusions]
  % Was the project successful? What did you learn? What might you
  % have done differently?

  Our team has thoroughly enjoyed the process that led to the creation
  of Visigoth. As of today, we are very proud of the result and we plan to
  release it to the wider public in the near future.

  While we could have improved in some areas, the development of
  Visigoth has been very successful in what matters more: constantly
  delivering, on time, the features requested by the client while
  maintaining a clean and maintainable code base.
  For this reason we are satisfied not only with the end
  result, but also with how smooth the development process was, and we
  think our client is satisfied as well.

\end{description}

\end{document}
