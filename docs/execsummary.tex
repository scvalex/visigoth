\documentclass[a4paper,11pt]{article}
\parskip 3pt

%% %%%%%%%%%%%%%%%%%%%% BEGIN PACKAGES %%%%%%%%%%%%%%%%%%%%

%%\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\usepackage{fullpage}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\hypersetup{pdfborder=0 0 0}

%% Images
\usepackage{graphicx}

%% Side-by-side images
\usepackage{subfig}

%% Wrapped figures
\usepackage{wrapfig}

%% Drawing trees and other stuff
\usepackage{tikz}
\usetikzlibrary{trees,arrows}
\usepackage{amssymb}

%% Pseudocode
\usepackage[noend]{algorithmic}
\algsetup{indent=1.5em}

%% Linux Libertine
\usepackage[T1]{fontenc}
\usepackage{libertine}
\renewcommand*\oldstylenums[1]{{\fontfamily{fxlj}\selectfont #1}}

\let\stdhref\href
\renewcommand{\href}[2]{\stdhref{#1}{\texttt{#2}}}

\newcommand{\mailto}[1]{\href{mailto:#1}{#1}}

\let\stdsection\section         % because LaTeX cannot handle
                                % recursive commands
\renewcommand{\section}{\newpage\stdsection}

\let\tikzsquare\square
\renewcommand{\square}{\ensuremath\tikzsquare}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\buzz}[1]{\emph{#1}}
\newcommand{\magic}[1]{\buzz{#1}}

\newcommand{\myhref}[1]{\href{http://#1}{#1}}

\newcommand{\Qt}{\buzz{Qt} }
\newcommand{\Cpp}{\buzz{C++} }
\newcommand{\OpenGL}{\buzz{OpenGL} }
\newcommand{\FADE}{\buzz{FADE} }

%% Clubs and widows. Avoid them like the plague.
\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

%% %%%%%%%%%%%%%%%%%%%% END COMMANDS %%%%%%%%%%%%%%%%%%%%

%Visigoth is a tool to generate, analyse and visualise Small World
%Networks. These are particular kinds of graphs which \emph{look} like naturally
%grown networks and share many mathematical properties with them.  For instance,
%friendship graphs and graphs of followers in modern web-based ``social
%networks'' are Small World Networks.

%As an educational tool Visigoth allows users to explore Small World Networks and
%hence can be used as an introduction to them. By exploring these networks users
%will have a firmer, more intuitive grasp of the mathematical properties they
%exhibit.

%The networks may be generated using several algorithms, allowing users to
%compare their output and its adherence to the properties of Small World
%Networks. The network generation algorithms in Visigoth form a smooth
%progression in the number of exhibited desired properties from completely random
%graphs, generated by the Erd\H{o}s-R\'{e}nyi algorithm, to fully compliant Small
%World Networks, generated by the Preferential Attachment
%algorithm. Additionally, Visigoth can connect to social networking platforms
%such as \Twitter to fetch and display real-world networks.

%We should keep it 2 pages long at most and should have the same structure as
%the Report

\begin{document}
\title{Visigoth --- Graph Visualisations}
\author{
  Andreea-Ingrid Funie\\\mailto{aif109@doc.ic.ac.uk}\and
  Alexandru Scvor\c tov\\\mailto{as10109@doc.ic.ac.uk}\and
  Francesco Mazzoli\\\mailto{fm2209@doc.ic.ac.uk}\and
  Marc-David Haubenstock\\\mailto{mh808@doc.ic.ac.uk}\and
  Maximilian Staudt\\\mailto{ms9109@doc.ic.ac.uk}
}
\date{Abbas Edalat (\emph{supervisor})\\\mailto{ae@doc.ic.ac.uk}}
\maketitle

\begin{description}
\item[Introduction]
  % High Level, Nontechnical Description Why you should buy this
  % product/listen to this presentation? What is the
  % functionality of the product?

  Visigoth is a tool to generate, analyse and visualise Small World
  Networks. These are particular kinds of graphs which \emph{look}
  like naturally grown networks and share many mathematical properties
  with them.  For instance, graphs of followers in social networks,
  graphs of links between websites and graphs of academic citations
  are Small World Networks.

  \item[Functionality]
  % Should we add here what is able to do?

  Visigoth is an educational tool that introduces these graphs by
  example.  Exploring these in 2D/3D, users gain a firm and intuitive
  grasp of the mathematical properties they exhibit.

  Mathematically, Small World Networks are graphs that exhibit three
  properties: low average path length, high clustering, and scale-free
  degree distribution.

  Visigoth generates networks with several algorithms which present a
  smooth progression in the number of desired properties their output
  exhibits. The algorithms are: Erd\H{o}s-R\'{e}nyi, Watts-Strogatz,
  Barabasi-Albert, Bipartite, and Preferential attachment with
  clustering. Additionally, Visigoth can connect to social networking
  platforms such as Twitter to fetch and display real-world networks.

  Users can regenerate graphs and add, move, reshuffle, as well as
  highlight nodes and their edges. They can zoom and pan graphs, and,
  in 3D mode, they can rotate and ``fly'' through the graph.

  Users may also customize the appearance of the generated graph by
  changing the colour of the edges, the nodes and the background.
  Finally, Visigoth supports taking snapshots of graphs and exporting
  them to PNG or JPEG files.

\item[Technical Description]
  % B. Short Technical Description; Short introduction into
  % technologies used Design of your software, possibly including a
  % diagram of the major components of the project; Main achievements

  Building Visigoth, we employed a variety of tools:

  \begin{description}
    \item[\Qt] The UI is built using Nokia's desktop application
      framework. \Qt is open-source, cross-platform, comes with a
      comprehensive library, and extensions to \Cpp objects. Together,
      these features considerably simplified \Cpp development, and
      shortened development time.

    \item[Force-directed algorithm] To draw our graphs, we use an
      optimised, state of the art force-directed
      algorithm\footnote{each node is treated as a charged particle
        and each edge as a rubber band so that nodes repel each other
        while edges keep clusters together}. We sped up our na\"ive
      code by implementing a 3D version of the \FADE approximation
      algorithm, which treats distant node clusters as single
      entities.

    \item[\Cpp] Despite its complexity and low-level nature, \Cpp has
      served us well. Because of the large availability of libraries,
      high performance and abstraction capabilities, it enabled us to
      develop a better product.

    \item[\OpenGL] Our graph is rendered using \OpenGL for performance
      reasons. We found that using other backends (\buzz{Cairo}, \Qt),
      we would not be able to render more than a few hundred
      nodes. Using \OpenGL, we can draw thousands of nodes while
      animating the graph in real-time, both in 2D and 3D.
  \end{description}

\item[Software Engineering Issues]
  % C. Software Engineering Issues: What technology was used and why;
  % what other technology was considered but not used and why; Any
  % technical challenges encountered and how addressed; Any risks
  % anticipated, and how mitigated? Any collaboration/coordination
  % difficulties encountered and how addressed; Development and
  % testing methods and/or tools used; comparison of plans with actual
  % achievements; Estimates of length of code in each of the
  % components, or any other comparable measure of the effort
  % required; Summary of each team member's contributions

  Building Visigoth, we overcame a number of difficulties by splitting
  it into several independent components:

  \begin{description}
  \item[Tests] The functional tests check that user actions cause the
    expected behaviour.

  \item[GUI] The user-visible component relies heavily on \Qt's widget
    library and \OpenGL.

  \item[GraphScene] The graph layout component is the \emph{model} and
    \emph{controller} in Visigoth's overall Model-View-Controller
    design, supplemented by the \textbf{GUI} as the \emph{View}.

  \item[Algorithms] The last component are the graph generation
    algorithms. By implementing the \code{Algorithm} interface, they
    are easily plugged into the \code{GraphScene}.
  \end{description}

  Work was divided within the team such that each member would focus
  on developing a particular component and reviewing another. We chose
  an iterative development model where each iteration consisted of
  adding a small number of features to the existing
  product. Furthermore, our practice of peer-review ensured that the
  whole team stayed up to date about the state of the project, exposed
  unnoticed bugs and maintained an always-releasable codebase.

  Further promoting group awareness of the project's state, we held
  frequent short meetings true to the idea of \emph{scrum}. In these
  whole-group meetings, held once every few days, team members shared
  comments on the features they were working on at the time and the
  future outlook of the project.

\item[Validation]
  % D. Validation and Conclusions How did you validate your product?

  We held meetings with \emph{the client}\footnote{We distinguished
    between \emph{the client} (i.e.  the person ``paying'' for the
    development of Visigoth) and \emph{the users} (i.e. the people who
    would end up using Visigoth).} near the end of each iteration in
  order to report on our progress and to get feedback on new
  developments. These meetings would consist of a short demo of newly
  added features, a short ``impromptu'' usability test and a
  discussion on what new features should be the focus of the following
  iteration.

  The feedback received at the end of each iteration was consistently
  positive. As the interface always met our client's demands, only
  small changes were necessary from iteration to iteration.

  Furthermore, we asked volunteers (``users'') to try accomplishing
  certain tasks in Visigoth while we watched. At the end, we would ask
  what felt awkward or wrong. The lasting impression was that they
  were happy with the software, but watching them struggle with
  certain aspects led to improvements in usability.

\item[Conclusions]
  % Was the project successful? What did you learn? What might you
  % have done differently?

  We enjoyed building Visigoth very much. We are very proud of the
  result and we plan to release it to the wider public in the near
  future.

  While we could have improved in some areas, the development of
  Visigoth has been successful in what matters most: consistently
  delivering on time the planned features while maintaining a clean,
  maintainable codebase. For this reason we are satisfied not only
  with the end result, but also with how smooth the development
  process was, and we believe our client is also satisfied.

\end{description}

\end{document}
