\documentclass[a4paper,11pt,titlepage]{article}
\parskip 3pt

%% %%%%%%%%%%%%%%%%%%%% BEGIN PACKAGES %%%%%%%%%%%%%%%%%%%%

%%\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\usepackage{fullpage}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{pdfborder=0 0 0}

%% Images
\usepackage{graphicx}

%% Side-by-side images
\usepackage{subfig}

%% Drawing trees and other stuff
\usepackage{tikz}
\usetikzlibrary{trees,arrows}
\usepackage{amssymb}

%% Pseudocode
\usepackage[noend]{algorithmic}
\algsetup{indent=1.5em}

%% Linux Libertine
\usepackage[T1]{fontenc}
\usepackage{libertine}
\renewcommand*\oldstylenums[1]{{\fontfamily{fxlj}\selectfont #1}}

%% %%%%%%%%%%%%%%%%%%%% END PACKAGES %%%%%%%%%%%%%%%%%%%%


%% %%%%%%%%%%%%%%%%%%%% BEGIN COMMANDS %%%%%%%%%%%%%%%%%%%%

\let\stdhref\href
\renewcommand{\href}[2]{\stdhref{#1}{\texttt{#2}}}

\newcommand{\mailto}[1]{\href{mailto:#1}{#1}}

\let\stdsection\section         % because LaTeX cannot handle
                                % recursive commands
\renewcommand{\section}{\newpage\stdsection}

\let\tikzsquare\square
\renewcommand{\square}{\ensuremath\tikzsquare}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\buzz}[1]{\emph{#1}}
\newcommand{\magic}[1]{\buzz{#1}}

%% %%%%%%%%%%%%%%%%%%%% END COMMANDS %%%%%%%%%%%%%%%%%%%%

%% %%%%%%%%%%%%%%%%%%%% BEGIN COLORS %%%%%%%%%%%%%%%%%%%%

\definecolor{cffffff}{RGB}{255,255,255}
\definecolor{c787aff}{RGB}{120,122,255}
\definecolor{cff7374}{RGB}{255,115,116}
\definecolor{c79ff79}{RGB}{121,255,121}
\definecolor{cff7374}{RGB}{255,115,116}
\definecolor{c7372ff}{RGB}{115,114,255}

%% %%%%%%%%%%%%%%%%%%%% END COLORS %%%%%%%%%%%%%%%%%%%%


%% Final Report -- due: 9th Jan 2012, at 11:00
%% Contents for Final Report: The project report should not be longer than 45 pages, and might be organized according to the following structure:

%% A. High Level, Nontechnical Description Why you should buy this product/listen to this presentation? What is the functionality of the product?
%% B. Short Technical Description
%% Short introduction into technologies used
%% Design of your software, possibly including a diagram of the major components of the project
%% Main achievements
%% C. Software Engineering Issues:
%% What technology was used and why; what other technology was considered but not used and why
%% Any technical challenges encountered and how addressed
%% Any risks anticipated, and how mitigated?
%% Any collaboration/coordination difficulties encountered and how addressed
%% Development and testing methods and/or tools used; comparison of plans with actual achievements
%% Estimates of length of code in each of the components, or any other comparable measure of the effort required.
%% Summary of each team member's contributions
%% D. Validation and Conclusions How did you validate your product? Was the project successful? What did you learn? What might you have done differently?
%% E. Bibliography
%% F. Appendix The appendix is optional, and does not count towards the 45 pages. It may contain thing like: User guide, installation instructions; more extensive design, testing, statistics etc.
%% Feel free to re-use material from the previous reports as you see fit, but make sure that the final report presents a coherent story. Ask advice from your supervisor. You might also draw inspiration from the instructions about writing up your individual project.

%% Bear in mind, that most of the project assessors will not have followed the project throughout and will only have a short time to listen to a presentation or see a demonstration. For this reason they will rely heavily on the report to judge the project.

%% The report should be submitted to SGO in form of a hard copy, as well as electronically through CATE.

\begin{document}
\title{\Huge Visigoth\\\Large Graph visualisations}
\author{
  Andreea-Ingrid Funie\\\mailto{aif109@doc.ic.ac.uk}\and
  Alexandru Scvor\c tov\\\mailto{as10109@doc.ic.ac.uk}\and
  Francesco Mazzoli\\\mailto{fm2209@doc.ic.ac.uk}\and
  Marc-David Haubenstock\\\mailto{mh808@doc.ic.ac.uk}\and
  Maximilian Staudt\\\mailto{ms9109@doc.ic.ac.uk}
}
\date{January 2012}
\maketitle

\begin{abstract}
%% FIXME: This needs more work.

Visigoth is a tool to generate, analyse and visualise Small World
Networks. These are particular kinds of graphs which \emph{look} like
natural networks and share many mathematical properties with them.
For instance, the friendship graphs and graphs of followers in modern
web-based social networks are Small World Networks.

Visigoth is an educational tool that allows users to explore Small
World Networks and hence can be used when introducing them. By
exploring these networks, users will have a firmer, more intuitive
grasp of the mathematical properties they exhibit.

The networks may be generated by one of several algorithms which
allows users to compare the varying quality of their output. The
generated networks form a smooth progression in the number of
exhibited desired properties from completely random graphs ---
generated by the Erdos-Renyi algorithm --- to Small World Networks ---
generated by the Preferential Attachment algorithm. Additionally,
Visigoth can connect to social networking platforms such as Twitter to
display real networks.
\end{abstract}

\tableofcontents




\section{Introduction}
%% This section corresponds to A in the requirements.

%% This section should contain most of the references to hamm10 and
%% oconn11.

Complex networks are ubiquitous in nature and society.

The structural and dynamical properties of complex networks are
non-trivial, and powerful computer architecture is needed for being
able to compute the required statistical analysis. As a result, it is
only in the last decade or so that we have been able to study the vast
data sets that describe real networks.\cite{oconn11}

The structural properties of real networks have been studied
extensively over the years. The main interest was focused on the fact
that many real networks share common characteristic properties. These
networks have low average length path, high clustering coefficient and
scale-free degree distribution. \cite{oconn11}

In order to be able to further understand the behaviour of real
networks, we simulate their dynamics on randomly generated networks.
For an accurate modelling of their behaviour we need to generate and
observe the results of algorithms which present the characteristic
structural properties of this kind of networks. \cite{oconn11}

\subsection{Realistic looking networks}
%% This subsection should *not* use the term ``Small World Networks''.
%% The point is to describe what properties we want.  The SWN
%% subsection below should be used in order to explain how they fit
%% the requirements.

%% FIXME: Define the qualities of the networks we want.  These
%% shouldn't be too mathy, just a layperson explanation (e.g. the
%% nodes shouldn't be too far apart, the number of neighbours should
%% fit a natural distribution).

The networks we are interested in are mathematical graphs in which
most nodes are not neighbors of one another, but they can be reached
from every other by a small number of steps. In the context of a
social network, this results in the \emph{``small world
  phenomenon''} \footnote{FIXME: citation needed} of strangers being
linked by a mutual acquaintance.

\subsubsection{Uses}

%% FIXME: Explain how networks with the above properties are useful.

Examples of real networks in the real-world are:

\emph{Social networks, neural networks, ecosystems, the World Wide
  Web, electrical power grids and protein networks} are all complex
networks that exhibit a range of understanding dynamic behaviour that
currently escape our understanding. \cite{oconn11}

Ideas from network science have been applied to the analysis of
metabolic and genetic regulatory networks, the design of robust and
scalable communication networks both wired and wireless, the
development of vaccination strategies for the control of disease, and
a broad range of other practical issues. \cite{complexNets}

\subsubsection{The maths}

%% FIXME: Give formal mathematical definitions for qualities.

\begin{description}
 \item [Networks] 

A \(network\) is a graph, an ordered pair \emph{G(V,E)} comprising a set of
\(vertices\), \emph{V}, and a set of \(edges\), \emph{E}. An \emph{edge} is a 
2-element subset of \emph{V} representing a \emph{connection} between a pair of \emph{vertices}. \cite{oconn11}

The \(degree\), \emph{K\lowercase{i}}, of vertex \emph{i} is the number of 
vertices that it is connected to.

The \(average\) \(degree\), \emph{k}, of a network is 
\begin{equation}
\ k =\frac{2m}{N} ,
\end{equation}
 where \(m\) is the number of edges in the network.

\item [Six degress of separation] 

This concept is the idea that everyone is approximately six steps away, by 
introduction, from any other person on Earth. 

A group of people can be represented by a \emph{social network}, where individuals are 
the vertices and an edge betwen individuals represents acquaintance. 

The steps from one individual to another are then the edges that must be 
traversed to connect them. We refer to the number of steps from one 
individual to another as the \emph{shortest path length} between them. \cite{oconn11}

\item [The Small-World Effect]

\emph{The ``small-world effect" denotes the result that the average distance
linking two nodes belonging to the same network can be orders of magnitude
 smaller than the number of nodes making up the network.} \cite{complexAdapt}

Frigyes Karinthy was the first proponent of the six degrees of separation concept
 in his short story \emph{``Chains"} (1929). 

The small world experiment (done by Stanley Milgram and other researchers in the 1960s), formalised the concept. In this, letters were sent to randomly selected individuals
 asking them to forwards the letter to a randomly selected target. If the target
 was unknown by them, they should have sent the letter to a friend or relative
 who was more likely to know the target. Milgram's experiment concluded that the \emph{shortest path length} between individuals is, on average, $6$.

\item [Properties of Real Networks] 

\begin{itemize}
%FIXME: fix the space so that the items from the itemize sections appear from a
%new line
\item Low average path length.

\item High clustering coefficient.

\item Scale-free degree distribution.

\end{itemize}

\item [Path Length]

We can apply Dijkstra's algorithm or A* for finding the shortest path length,
\(d(v\lowercase{i},v\lowercase{j})\), between two vertices, \(v\lowercase{i}\), 
\(v\lowercase{j}\), in a network.

The \(average\) \(path\) \(length\), L\lowercase{G}, is the average of the 
shortest path length over all pairs of vertices:

\begin{equation}
\ L\lowercase{G} =\frac{1}{N(N-1)} \sum_{i, j} d(v_i,v_j),
\end{equation}
where \(d(v\lowercase{i},v\lowercase{j})\) \(=\) $0$ when there is no path between
 vertices \(v\lowercase{i}\), \(v\lowercase{j}\).

\item [Clustering coefficient]

\emph{Clustering} is about the tendency of real networks to form \emph{cliques}.  
For example, in social networks, \(cliques\) represent circles of friends or 
acquitances in which every member knows every other member.

The \(clustering\) \(coefficient\) proposed by Watts and Strogatz is calculated 
for each vertex, \lowercase{i}.

\begin{equation}
\ C\lowercase{i} =\frac{2E\lowercase{i}}{k\lowercase{i}(k\lowercase{i}-1)},
\end{equation}
where \(k\lowercase{i}\) is the number of neighbours of vertex \(\lowercase{i}\) and 
\(E\lowercase{i}\) is the number of edges between the neighbours of vertex \(\lowercase{i}\).

The \(average\) clustering coefficient over the network is:

\begin{equation}
\ C\lowercase{avg} = \frac{1}{N}\sum_{i=0}^{N} C_i
\end{equation}

\item [Scale-free distribution]

Barabasi and Albert showed that real networks such as the World Wide Web are 
scale-free.

The \emph{degree distribution} of scale-free networks follows a \(power\) \(law\).

\begin{equation}
\ P(k) \sim k^{-\gamma},
\end{equation}
where \(P(k)\) is the probability that a node in the network will be of degree \(k\).

\end{description}

\subsection{Small World Networks}

Small World Networks derive their denomination from the well-known
Small World Hypothesis\footnote{FIXME: citation needed}, which states
that any two persons are related through a chain of at most seven
friends\footnote{FIXME: citation needed}.

Indeed, Small World Networks are graphs resembling the connections
within human social networks, where nodes represent people, and edges
between nodes represent relations of some sort\footnote{FIXME:
  citation needed, probably one of the two main papers}.

For example, if someone were to draw every user\footnote{or at least a
  \emph{large} number of users} of a social network (e.g. Twitter) on
a canvas and then connect each pair of them if either is ``following''
the other or if they are ``friends'', the resulting graph is a Small
World Network. Over the course of time, several mathematical
algorithms that generate random Small World Networks have been
discovered. However, the resulting graphs have only lately begun to
resemble those that have grown naturally in the form of social
networks.

%% FIXME: Huh?  Are they really SWNs if they don't resemble the
%% natural graphs?  Not by our definition.  So, either the definition
%% is wrong, or the last two sentences need to be rewritten.

%% FIXME: Explain how SWNs exhibit *all* the properties we're
%% interested in.  Include some math.

\subsection{Introducing Visigoth}

Visigoth makes peeking into the current state-of-the-art of artificial
Small World Networks simple and fun. By integrating existing
generation algorithms and visualisations into a single, easy-to-use
interface, the user can make a head start into the small world of
Small World Networks and:
\begin{itemize}
  \item see how these algorithms have improved on each other over time
    generating increasingly better networks,
  \item see the effects of changing algorithm parameters on the
    resulting networks, and
  \item compare them to naturally grown networks.
\end{itemize}

\subsection{Customer requirements and iterative (re-)specification}

% What our customer wanted.
%
% What we suggested, and what he finally wanted.
% (E.g. once we suggested 3D he didn't want to let go of the idea)
%
% Finally, on overview of what we did, and what we added as a bonus.
% Possibly another subsection.

Our customer initially asked for a simple, easy-to-use, graphical
application that would allow him to compare various Small World
Network generation algorithms and parameters thereof, both visually
by looking at the graphs as well as numerically by calculating
several statistical properties of the graphs.
We suggested several additional features, such as a 3D view of the
graphs generated, real-world data fetching from social networks
(Twitter) and graph interaction. Following our customer's highly
positive reaction to our suggestions we then added them to our
product, creating a comprehensive base for analysing graphs that
may be re-used for other mathematical projects in the future.




%\section{In detail}
%% This section corresponds to B in the requirements

\section{Generating Small World Networks}
%% For all of the following, we should include a hand-drawn sketch
%% illustrating the graph generated by the algorithm and an exported
%% image of a large graph Visigoth generated.

On request of our customer we have implemented several generation
algorithms for Small World Networks which have been analysed over
the course of the last decade.

\subsection{Erdos-Renyi}
% FIXME
Generates a random graph.

\subsection{Watts-Strogatz}
% FIXME
Creates a ring of connected nodes and re-links some nodes randomly
within that ring.

\subsection{Bipartite model}
% FIXME
Creates a bipartite graph and for all nodes, links all nodes of
set A connected to the same node in set B. Finally, removes all
nodes form set B.

\subsection{Preferential attachment}
% FIXME
Selects a node for attachment depending on the number of edges
they hold compared with the whole system. Creates links to nodes
neighbouring that node.

\subsection{Barabasi-Albert}
% FIXME
Nodes added as in preferential attachment, but with no clustering.

\subsection{Real Small World Networks}
% FIXME
Finally, as Visigoth is supposed to help in analysing Small World
Networks, it can also fetch real world data from `live' social
networks Twitter and identi.ca.




\section{Visigoth functionality}

% FIXME: Describe what we can do. Generate, set properties, save
%        screenshots, move nodes, fly in 3D, the kitchen sink.



\section{Visigoth technologies}

\subsection{Qt}

The UI toolkit, standard library replacement, and application
framework Visigoth uses is Qt\footnote{\url{http://qt.nokia.com/}}.

Visigoth relies heavily on some of Qt's features:
\begin{description}
\item [gui] Qt is famous for providing a cross-platform, high-level,
  UI toolkit that automatically uses the native drawing systems on
  each host platform. All of Visigoth's user visible interface was
  built using this framework. A more detailed explanation is included
  in Section \ref{gui};
\item [meta-objects] Qt supplements the venerable C
  pre-processor\footnote{\url{http://gcc.gnu.org/onlinedocs/cpp/}}
  with its own \buzz{meta-object
    compiler} \footnote{\url{http://developer.qt.nokia.com/doc/qt-4.8/moc.html}}.
  This preprocessor augments normal C++ objects with modern features
  such as introspection and signals. We use introspection extensively
  in our tests; see Section \ref{tests}. We use signals to decouple
  objects, which leads to a cleaner design and has the side-effect of
  simplifying writing test cases (mock and stub objects are not
  necessary anymore); for details, see Section \ref{interaction};
\item [xml] Like most modern frameworks, Qt provides an \buzz{XML}
  parsing
  library\footnote{\url{http://developer.qt.nokia.com/doc/qt-4.8/qtxml.html}}.
  In addition to a standard \buzz{SAX} parser, it exposes an extremely
  clean \buzz{HTML DOM}-like interface for manipulating \buzz{XML}
  documents. We use it in order to parse results from queries to
  online sources such as \href{http://twitter.com}{Twitter} and
  \href{http://identi.ca}{Identi.ca};
\item [containers] Qt provides a fully-featured library of containers
  similar to Java
  \buzz{collections} \footnote{\url{http://docs.oracle.com/javase/1.5.0/docs/api/java/util/package-summary.html}}
  and significantly more complete than the standard or SGI
  \buzz{STL}\footnote{\url{http://www.sgi.com/tech/stl/}}. The
  availability of these meant that advanced data-structures were one
  less concern to worry about during development;
\item [concurrency] Qt also provides high-level
  threading\footnote{\url{http://developer.qt.nokia.com/doc/qt-4.8/threads.html}}
  and
  concurrency\footnote{\url{http://developer.qt.nokia.com/doc/qt-4.8/threads-qtconcurrent.html}}
  APIs. Our experiments showed that separating the CPU-intensive
  computations (e.g. generating new networks, calculating layout
  positions) onto a separate thread could speed up certain operations
  by as much as a factor of $6$. The concurrency API, which provides
  functional programming style parallelized primitives
  (e.g. \code{map}, \code{filter}) could further improve performance.
  This is an area where further work could be done in Visigoth.
\end{description}

\subsubsection{Plugins}

Qt has a healthy plugin ecosystems, with a myriad of libraries
available to plug into the main framework. We make use of two of
these, namely
\buzz{QCA} \footnote{\url{http://delta.affinix.com/qca/}} and
\buzz{QOAuth} \footnote{\url{https://github.com/ayoy/qoauth/wiki}}.

\begin{description}
\item [QCA] The \buzz{Qt Cryptographic Architecture} includes many
  security providers for Qt application. We used the \buzz{OpenSSL}
  provider when establishing TLS-secured channels to the online
  sources (e.g. \href{http://twitter.com}{Twitter});
\item [QOAuth] This library is an implementation of the \buzz{OAuth
  2.0}\footnote{\url{http://oauth.net/}} secure API authorization
  standard (\buzz{OAuth} is becoming the de-facto authorization
  mechanism on the web); again, this was required in order to
  authenticate with the online sources.
\end{description}

\subsubsection{Cross-platform}

Thanks to Qt's cross-platform nature, in general, and to
\buzz{qmake} \footnote{\url{http://developer.qt.nokia.com/doc/qt-4.8/qmake-manual.html}},
in particular, Visigoth works on Windows, OSX and Linux with a minimum
of fuss on the development side.

\begin{description}
\item [qmake] Qt's build system, \buzz{qmake}, takes a high level
  project description and outputs platform-specific build files
  (\buzz{Makefile}s on Linux, \buzz{XCode} projects on OSX and
  \buzz{Visual Studio} projects on Windows). It also simplifies
  finding external libraries (by using its own mechanism on Linux,
  \buzz{pkg-config} on OSX and the registry on Windows).
\end{description}

The only tweaks necessary for Visigoth to build on each of the above
platforms are a few defines to deal with the misplaced \buzz{OpenGL}
headers on OSX and few conditionals in the project description to
handle the library finding on Windows.

The following screenshots show Visigoth working on the three
platforms.
%% FIXME: add screenshots

\subsubsection{Rapid prototyping}

One of lesser known advantages to using Qt we discovered is rapid
prototyping. Point in case, the original prototype for Visigoth took
two days to write. It included roughly half of the customer's
\emph{must-have} features, was cross-platform and was visually
impressive.

\subsection{OpenGL}

After being left unsatisfied with the performance achieved with a
screen renderer using Qt graphics primitives, we looked for a `bare-metal'
graphics output solution in order to eliminate the graphics bottleneck.
Thanks to OpenGL\footnote{OpenGL documentation:
https://www.opengl.org/documentation/},
we can now draw even large graphs very quickly,
no matter whether in 2D or in 3D.

OpenGL itself is a graphics drawing interface commonly used to
leverage hardware acceleration for common operations, such as vector
transformations necessary to compute 3D graphics. Every modern
operating system uses it to animate its user interface smoothly,
and games and professional CAD (Computer Assisted Design) applications
have long used it for real-time 3D graphics interaction.

Not only are we leveraging this power to speed up our graph
visualiser, but this may also allow for ports to other
platforms in the future. Thanks to the Qt/OpenGL base, Visigoth
could theoretically be compiled for mobile phones and slates
with minimal porting effort.

OpenGL made several extensions possible, as outlined in the following
subsections.

\subsubsection{3D graphs and camera}
OpenGL provides only the very fundamental drawing primitives like
lines and points - however, it includes hardware acceleration for
vector transformation. This allows the implementation of a virtual
3D space through which a `camera' can move. As even this is actually
a composite functionality, we wrote a helper code library (glAncillary)
to provide us with easy camera transformation functions. They are
used whenever the user decides to move around the graph, i.e. to
pan or tilt.

\subsubsection{Selection}
The OpenGL interface also eases object selection: Since it is
responsible for the depth transformations when drawing the graphics,
it can also perform the inverse of these transformations from any
given point on the drawing surface, finding the original point
in space. In this case we check the position the mouse pointer is at
and find the object selected by the user. This is fundamental in
allowing us to move nodes around and selecting them for statistical
analysis.

\subsection{C++}

Visigoth, ignoring the XML files describing the interface, is entirely
written in \buzz{C++}. Initially, while being conscious of its disadvantages,
we made this decision for one reason: \buzz{Qt}. As described in the previous
paragraph, the library by TrollTech is so convenient that alone
justifies the use of C++ instead of another safer language.

All in all, we think it was the right decision. The appreciation of
C++ varies in our team, but looking back we are confident that C++ was
one of the best choices considering the nature of the application we
have been developing.

The main advantages were:

\begin{description}

\item [Availability of tools and library] As mentioned, \buzz{Qt} alone
  was a deal sealer, but the fact that we were able to access OpenGL
  `natively' (in a Qt widget) was also a big advantage. While interfaces
  to both libraries exist in other languages as well, we felt that
  sticking to Qt's `native' C++ environment would be the most stable
  solution and that the foreign language bindings would have degraded
  performance.

\item [Performance] We did not consider this factor at the beginning,
  but a few weeks into the project we started hitting various
  bottlenecks. We can only speculate about actual performance gains,
  but the fact that we were using
  C++ allowed us to fine-tune the application (specifically on the
  memory management side) in a way that we would not be able to do
  with managed languages. Furthermore, having an optimising compiler
  instead of an interpreter or JIT (as it would have been the case
  using a language like Python or Ruby) aided performance as well.

\item [Abstraction] The previous two points (especially the second)
  are partly shared by C++ with its predecessor, C. However, the
  possibility to structure our code into classes facilitates greatly
  structuring a medium sized application like Visigoth, especially
  considering that we had to coordinate five people working together.
  For example, there is a common \code{Algorithm} interface which all
  graph generation algorithms have to implement. They can then
  be plugged into the main widget at will: this kind of operation
  would have been much more laborious and less type-safe in C.

\end{description}

However, C++ also has its downsides:

\begin{description}

\item [Unmanaged memory] This is by far C++'s most ``dangerous''
  feature (or better, lack of feature). While enabling greater control
  and thus greater performance, it requires a much more attentive
  analysis of the code. This is in a way a good thing, since it forces
  the programmer to reason more about what the code is doing; but it
  also paves the way to a nasty class of bugs and memory leaks that
  more than once took hours (in one case days) to track down. This is
  a somewhat controversial subject in our team as well as the broader
  programming community and our opinions differ on how much better a
  garbage collected language would have been when considering the loss in
  performance. C++ also has the characteristic (required by its
  unmanaged nature) of allowing objects to be used in the heap through
  pointers and on the stack as values, which slows down compilation
  considerably - when changing a header file, all code that uses
  that object as a value has to be recompiled. Moreover, C++ allows two
  kinds of references: immutable references and C-style pointers, the
  former with
  a rather confusing syntax - references are indistinguishable from
  values when used. All these factors generate much confusion which is
  absent in most modern O-O languages.

\item [Language bloat] C++ is a very broad language with a number of
  esoteric language features. Notable examples are templates, operator
  overloading and ``friend'' attributes. Some of them are very
  useful and never harmful, e.g. the \code{const} keyword is a
  great mechanism to mark immutability at type level. However, some
  of them can and have been misused\footnote{For an hilarious example,
    see
    \url{http://weegen.home.xs4all.nl/eelis/analogliterals.xhtml}},
  and as a consequence ``when you're programming C++ no one can ever
  agree on which ten percent of the language is safe to use'' (Jamie
  Zawinski). This kind of ``programming language discipline'' is
  required when working on a C++ project and we had our fair share
  of arguments on which subset of the language is safe to use;
  nevertheless we think we have managed to keep the code clean to
  high standards in the C++ world.

\end{description}

This is of course only a very brief analysis of C++, but it does
highlight the points that we felt the most while developing Visigoth.




\section{Engineering Visigoth}
%% This section corresponds to C in the requirements

\subsection{GUI}
\label{gui}

\subsection{Classes}
%% This is an overview of the classes (including a class diagram).

\subsection{Object interaction}
\label{interaction}
%% This is an overview of the signals sent between objects (or of the
%% public interfaces they subscribe to).

\subsection{Graph drawing}

We looked into various graphics libraries which allow for
platform-independent drawing using primitives. Candidates were
\buzz{Cairo}\footnote{Cairo homepage: http://cairographics.org/},
\buzz{Qt} and \buzz{OpenGL}. The first two are the
most common 2D drawing libraries used in modern open-source
software; however, as they operate solely on the CPU, they proved
too slow for the large graphs we wished to visualise.

Therefore we decided to use \buzz{OpenGL} for drawing graphs on
the screen. Thanks to its hardware accelerated nature, we can now
(re-)draw thousands of nodes and edges often enough every second
to give the user the impression of a smooth interface when interacting
with the graph.

Implementing the camera handling, the node/edge drawing and the
interface allowing the user to `fly' through a 3D graph we also
developed a helper library, \code{glAncillary}. A significant portion
of our code can now be reused in similar projects using OpenGL,
and this is important since applications such as Visigoth require a
completely different type of graphics engine compared to the ones
commonly found e.g. in video games.


\subsection{Graph layout}
Laying out a graph is a tricky problem, mainly due to the fact that the
prime interest when engineering layouts is to please humans' taste
instead of some logical property. A wide array of such algorithms have
been proposed, and since drawing graphs is a central task in Visigoth,
we had to choose the one that fit best.

First we experimented with the existing solutions. One of the most
complete free graph-drawing algorithm is
OpenViz\footnote{\url{http://www.graphviz.org/}}, and it provides
various algorithms:

\begin{description}
\item [dot] A hierarchical layout, used for directed graphs. Our small
  world networks are not directed and it was clear from the beginning
  that they did not fit this model well.

\item [twopi, circo] Radial and circular layout, respectively. Again,
  unsuitable for the quasi-random networks that we use in Visigoth.

\item [neato] A spring model layout, which seemed to work reasonably
  well with random graphs.
\end{description}

The spring model seemed to be the best fit. This class of algorithm
work by treating edges like springs: in this way clusters of highly
connected nodes would be drawn together. To counter this force (that
would lead to nodes lumping together), nodes are treated as charged
particles of the same polarity, causing repulsion between every node
and the others.

When generating a graph, the nodes are first places at random
locations in the space. Then, we apply the algorithm repeatedly until
the forces are low enough that we can consider the graph to be stable.

Spring model algorithms are nice for two reasons:

\begin{itemize}
\item Good results: spring force algorithms produce pleasant graphs
  for almost all kind of networks. Some algorithms might produce
  better results for specific kinds of graph, but spring force
  algorithms are by far the more adaptive.

\item Ease of implementation: Our simple implementation of the
  algorithm take a little less then 50 lines of C++ code, and works
  well up to medium-sized graphs.

\item Real time drawing: force based algorithms can be used to show in
  real time the untangling of the graph, which is usually an
  interesting effect. It also permits interaction, for example in the
  form of node-dragging that changes the shape of the graph. We employ
  both techniques in Visigoth.
\end{itemize}

\subsubsection{FADE}

However, even a simple description of the algorithms reveals its high
cost. For each particle, we need to iterate through all the connected
nodes to calculate the spring forces, and more importantly through all
the particles of the graphs to calculate the repulsion forces. Thus,
the algorithm is \(O(n^2)\), where \(n\) is the number of nodes.

For this reason, our implementation works smoothly up to around a
\(1000\) nodes, but then performance degrades quickly, and the program
becomes unresponsive. Various solutions have been studied, most of
which rely on various approximations.

We chose to implement the \emph{FADE} algorithm \cite{fade}, which works by
recursively subdividing the graph space into sub-spaces, and then
treats sub-spaces as single particles when they are far enough. This
algorithm, while improving performance, is a lot more complex then the
naive one.

\begin{figure}
  \centering
  \subfloat[Graph view]{
    \input{quadtree-graph.tex}
  }
  \hspace{10pt}
  \subfloat[Tree representation]{
    \input{quadtree-tree.tex}
  }
  \caption{The QuadTree for a sample graph, empty branches omitted}
  \label{fig:quadtree}
\end{figure}

The first step is to build a data structure representing the recursive
subdivision. This kind of data structure is called a \emph{TreeCode},
which recursively subdivides the space until only one node remains in
the current space, or a maximum depth/minimum space size size is
hit. The space decomposition can be irregular (e.g. \emph{Voronoi}
spaces) or regular. In the latter case, the space is recursively
subdivided in squares. We chose to use a regular, 4-way space
decomposition, mainly due to its simplicity. This kind of structure is
called \emph{QuadTree}. Figure \ref{fig:quadtree} shows a sample
QuadTree for a Visigoth graph. In the QuadTree, each sub-quadrant
preserved the weighted centre of gravity relative to the contained
nodes.

Building the tree is the difficult part of the algorithm and can be
done in linear time. Once that is done, to calculate the non-edge
forces for a given node the algorithm proceeds as indicated in figure
\ref{proc:FADE}.

\begin{figure}[ht]
  \begin{minipage}[b]{0.5\linewidth}
    \input{fade-algorithm.tex}
    \caption{This procedure calculates the non-edge force of a given
      node \(n\), given the QuadTree \(q\). \(\vec{n}\) and
      \(\vec{q}\) indicate the vectors corresponding to the respective
      centers of gravity. \(\beta\) is an empirically determined
      parameter used to regulate the amount of force - \(75\) has
      worked well for us. \(\theta\) is central to the FADE algorithm
      and determines the amount of approximation. If \(\geq 1\) the
      algorithm is unstable, we used values between \(0.5\) and
      \(0.8\). See figure \ref{fig:theta} for a visual
      explanation. The mass of a quadrant is simply the number of
      nodes residing in it. }
    \label{proc:FADE}
  \end{minipage}
  \hspace{10pt}
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \input{fade-distance.tex}
    \caption{In this case, \(n_1\) and \(n_2\) are nodes and \(q\) is
      a quadrant with edge length \(s\). When calculating the non-edge
      force between \(n_1\) and \(q\), where \(s\) is the quadrant
      will be judged to be too close to approximate, since
      \(\frac{s}{d_1} > 1\), while \(n_2\) might be judged far enough,
      depending on \(\theta\).}
    \label{fig:theta}
  \end{minipage}
\end{figure}

Once implemented, the FADE algorithm lead to great speedups while
preserving good node placements. While drawing \(1000\) nodes is
already difficult with the simple algorithm, FADE can easily handle
\(10000\) nodes, after which other performance limits are hit (the
graph generation time and the OpenGL drawing).

After we implemented the 3D view we had to write an extension to FADE to support
3D, which proved to be straight forward. Now we have a 3-dimensional space,
which is recursively divided into $8$ cubes.


\subsection{Development methodologies}
% FIXME: This is text from Report 3.

\subsubsection{Peer review}
Our rule of thumb, ``\emph{the master branch is always releasable}'',
has been
the foundation of our testing practices. To adhere to this, we have
had to ensure that no bugs crept into the master branch. Towards this
goal, no changes are merged into master until at least another member
of the team reviews them. Through this practice of peer review the
whole team has stayed informed on the current state of the project
in addition to exposing and fixing bugs missed by the original code
author. While this does indeed slow done writing code, we like to
think that it otherwise shortens overall development time.

\subsubsection{Scrum}
To further promote group awareness of the complete state of the
project we held frequent short meetings true to the idea of scrum.
These were whole-group meetings held every few days, in which team
members shared comments on what features they were working on at
the time and the future outlook of the project.

\subsubsection{Client feedback}
Towards the end of each iteration, we held meetings with our client
in order to report on our progress and get feedback on new
developments. These meetings would consist of a short demo of newly
added features, a short "impromptu" usability test and a discussion
on what new features should be the focus of the following iteration.

The feedback we received at the end of each iteration was
consistently positive. The Visigoth interface always met our
client's demands and only minor changes have been made from
iteration to iteration, e.g. button placements. Most of the our
client's wishes referred to extensions to the functionality of
our product, such as a 3D rendering mode and the network generation
algorithms.


\subsubsection{Other users' feedback}
Near the end of each iteration we asked classmates and friends for their
sincere point of view concerning our progress and project overall, to that
specific point in time.

The last impression was that they were mainly happy. We followed their advice 
when it appeared. For example, at some point, they wanted to be able to 
customize the graph a bit more following their own taste. So, we added the 
possibility to change the color of the nodes, edges, background; to highlight 
selected nodes as well as their direct neighbours.



\section{Looking back}
%% This section corresponds to 'Conclusions' in part D of the requirements

\subsection{Validation}
%% The client is a happy puppy
% FIXME: This is text from Report 3

\subsubsection{Tests}
To automate regression detection we use a test suite written using
the Qt Unit-Testing framework, which covers a significant portion
of the codebase. In particular, it completely covers the intricate
algorithmic and UI logic encoded in the Algorithm classes. Running
the test suite can expose changes breaking rarely-used functions
which would have slipped past a quick tests by the coder.

The tests we use to determine our product's integrity are split
into two categories: system and interface tests. System tests focus
on the Visigoth back-end, i.e. memory consistency and build stability.
The interface tests were deployed to ensure that user input in the
graphical interface is successfully passed to and feedback returned
from the system's back-end. More specifically, the interface tests
encode a number of common use-cases and ensure that Visigoth indeed
behaves as per the user's expectations.

These user interface tests proved quite useful and revealed several
problems, all of them caused by internal API changes and code not
being updated to reflect the changes. These would manifest as
misleading readings on the Visigoth graph-information panels and
were thus caught by the use-case tests.

When testing our product, the most profound fault that was revealed
by our system tests were memory leaks, found in two separate
instances. The lessons to take away were twofold:
\begin{itemize}
  \item One the one hand, old code that sees no use and just rots
        should be removed immediately so that it cannot interfere
        with the newer infrastructure. We were still semi-maintaining
        internal structures for an old rendering front-end, though
        not cleaning them up properly. We have recently began to
        track test coverage statistics.  These should help us in
        identifying dead and duplicate code in the future.
  \item On the other hand, even a three-way merges as done by Git
        should be done with great care: merge conflicts between
        diverged branches may re-introduce old code, leading to
        the situation described above.
\end{itemize}

\subsubsection{Continuous Integration}
We use a Jenkins CI\footnote{http://jenkins-ci.org/} server. It is
set up to track the master branch. On receiving a change notification
from the central repository, it proceeds to do a fresh build of the
project, runs the tests and generates the coverage statistics. It
also keeps track of previous builds and aggregates information about
the overall health of the project.
The server is publicly accessible so that interested parties can get
a rough idea of what the current status of the project is. It is also
set up to notify team members (via the project mailing-list) when
problems occur.

\subsubsection{Stability under load}
Load-testing Visigoth is a straightforward affair: generate networks
with a large number of nodes. We have found our software to stay
sufficiently responsive even under load. This is especially true
since it is usually generating a high CPU load itself when
recalculating the node positions using the spring force model. In
particular, we met our initial goal of displaying thousands of nodes
in real-time.

\subsubsection{Style}
We have strived to use consistent style throughout the code and
documentation. To this extent, it fell to the reviewer doing the
merge to mention and fix any style issues. This has worked adequately
most of the time, and in the few instances where badly styled code
slipped through, subsequent global reviews remedied the problem in a
timely fashion.


\subsection{Documentation}
% FIXME: This is text from Report 3.

\subsubsection{Tools and policies}
We use Git\footnote{http://git-scm.com/} to manage our code base and
to enable parallel development; using its lightweight branching
extensively in our work-flow.  Additionally, the distributed nature
of Git enabled more efficient peer reviews, as we could pull/push
changes directly from one another. As a general policy, code needed
to be checked and corrected by at least one other developer before it
made its way into the master branch.

\subsubsection{Knowledge transfer}
Due to our peer review scheme, at least two people would know every
bit of code. Also, mutual interest in each other's area of expertise
has fostered cooperation in labs where problems were solved together
in eXtreme Programming setups (one person coding, the other watching
and correcting).

We also held periodic "Direct Mental Download" meetings in which one
team-member would dump his accumulated knowledge into the willing
minds of other team-member (referred to as recipients in our terminology).

Additionally, we shared relevant articles/papers between us to ease
the used principles understanding and to improve the existent work.
This exchange of written or verbal knowledge transfer allowed us not
only to improve team-working but to gain new technical skills as well.

%Add the Log-Book in appendix


\subsection{Functional testing}
\label{tests}




\subsection{People management and contributions}
%This is from Report 2 except the summary of contributions which is a new add

\subsection{Lessons learned}


\subsection{Ethical and Environmental Impact}
%Check Report 2

\addcontentsline{toc}{section}{References}
\begin{thebibliography}{9}

\bibitem{hamm10}
  David A. Hammond,
  \emph{Altruism in Small World Models}.
  Imperial College London,
  2010.

\bibitem{oconn11}
  Luke M. O'Connor,
  \emph{Algorithms for Constructing Realistic Networks}.
  Imperial College London,
  2011.

\bibitem{fade}
  Aaron Quigley and Peter Eades,
  \emph{FADE: Graph drawing, clustering and visual abstraction}.
  Department of Computer Science and Software Engineering,
  Univ. of  Newcastle, Australia, 2000.

\bibitem{complexAdapt}
Claudius Gros,
\emph{Complex and Adaptive Dynamical Systems}.
Springer,
2008.

\bibitem{complexNets}
  \url{http://en.wikipedia.org/wiki/Complex_network}

\end{thebibliography}

\end{document}
